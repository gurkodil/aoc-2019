use std::fmt;

enum Heading {
    LEFT = 0,
    RIGHT = 1,
    UP = 2,
    DOWN = 3,
}

impl fmt::Display for Heading {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self {
            Heading::LEFT => return write!(f, "LEFT"),
            Heading::RIGHT => return write!(f, "RIGHT"),
            Heading::UP => return write!(f, "UP"),
            Heading::DOWN => return write!(f, "DOWN"),
            other => return write!(f, "unknown: {}", other)
        }
    }
}

impl fmt::Display for Position {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}



impl Heading {
    fn parse(c: String) -> Heading {
        match c.as_ref() {
            "U" => return Heading::UP,
            "D" => return Heading::DOWN,
            "L" => return Heading::LEFT,
            "R" => return Heading::RIGHT,
            other => panic!("Unexpected heading: {}", other)
        }
    }
}

struct Grid {
    max_x: i16,
    max_y: i16,
    min_x: i16,
    min_y: i16,
}

struct Cmd {
    heading: Heading,
    steps: i16
}

struct Position {
    x: i16,
    y: i16,
}

impl Position {

    fn move_left(&mut self, steps: i16) -> i16 {
        self.x -= steps;
        self.x
    }

    fn move_right(&mut self, steps: i16) -> i16 {
        self.x += steps;
        self.x
    }

    fn move_up(&mut self, steps: i16) -> i16 {
        self.y += steps;
        self.y
    }

    fn move_down(&mut self, steps: i16) -> i16 {
        self.y -= steps;
        self.y
    }

    fn move_by_cmd(&mut self, cmd: &Cmd) {
        match cmd.heading {
            Heading::LEFT => self.move_left(cmd.steps),
            Heading::RIGHT => self.move_right(cmd.steps),
            Heading::UP => self.move_up(cmd.steps),
            Heading::DOWN => self.move_down(cmd.steps),
        };
    }

    fn clone(&mut self) -> Position {
        Position {
            x: self.x,
            y: self.y
        }
    }

    fn equals(&mut self, pos: &Position) -> bool {
        self.x == pos.x && self.y == pos.y
    }
}

struct Line {
    start: Position,
    end: Position
}

fn traverse(cmds: Vec<Cmd>) -> Vec<Line> {
    let mut current_position = Position {
        x: 0,
        y: 0
    };
    let mut lines: Vec<Line> = Vec::new();

    for cmd in cmds {
       let l1 = current_position.clone();
       current_position.move_by_cmd(&cmd);
       let l2 = current_position.clone();
       let line = Line { start: l1, end: l2 }; 
       lines.push(line);
    }

    lines
}


fn split_command(cmd: String) -> Cmd {
    let mut heading = String::from(cmd);
    let steps: i16 = heading
        .split_off(1)
        .parse()
        .expect("Bad format on steps");
    let heading = Heading::parse(heading);
    Cmd {
        heading: heading,
        steps: steps
    }
}

fn line_intersects(l1: &Line, l2: &Line) -> bool {
    
    let x1 = l1.start.x;
    let y1 = l1.start.y;
    let x2 = l1.end.x;
    let y2 = l1.end.y;

    let x3 = l2.start.x;
    let y3 = l2.start.y;
    let x4 = l2.end.x;
    let y4 = l2.end.y;

    let den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (den == 0) {
        return false
    }
    // Check if both lines have the same orientation
    if l1.start.x == l1.end.x && l2.start.x == l2.end.x
        || l1.start.y == l1.end.y && l2.start.y == l2.end.y {
        return false
    }

    true
}



fn format_input_line_to_commands(input: String) -> Vec<Cmd> {
    input.split(",")
        .map(|l| split_command(l.to_string()))
        .collect()
}

pub fn test_part_one() {
    println!("Hello world 2!");

    let l1 = "R8,U5,L5,D3".to_string();
    let l2 = "U7,R6,D4,L4".to_string();
    let cmd_line1 = format_input_line_to_commands(l1);
    let cmd_line2 = format_input_line_to_commands(l2);

    let mut wire_path1 = traverse(cmd_line1);
    let mut wire_path2 = traverse(cmd_line2);
    let mut record = 0;
    for wire1 in &mut wire_path1 {
        for wire2 in &mut wire_path2 {
            if line_intersects(&wire1, &wire2) {
                if wire1.start.equals(&wire2.start) {
                    let potential_record = wire2.start.x.abs() + wire2.start.y.abs();
                    if (potential_record > record) {
                        record = potential_record;
                    }
                    println!("FOUND {} {}", wire2.start, potential_record);
                } else if wire1.end.equals(&wire2.end) {
                    let potential_record = wire2.end.x.abs() + wire2.end.y.abs();
                    if (potential_record > record) {
                        record = potential_record;
                    }

                    println!("FOUND {} {}", wire2.end, potential_record);
                }
            }
        }
    }

    println!("Record: {}", record);



}
